Computer Architecture and OS:
    CPU, Memory and disk.
    Trends, Impact on OS.
    Architectural support for OS

OS talks to hardware, need to know features and drives new hardware features as OS requires.

CPU:
    Brain of computer: Fetch instructions, decode, execute and store on memor/registers.

Moore's Law
    Transistors double every one or two years. 5.56 billion in an 19-core Intel Xeon Haswell-E5
    114 billion in Apple M1 Ultra

Single core CPU:
- Job of OS is time-sharing (when to schedule which task)
When multicore: Parallel Computing
- Which task to which cores
    ** => May have performance implications due to cache contention -> Contention-aware scheduling

Multiprocessor:
Shared cache: That lets you access memory belonging to other processors.
- Non-uniform memory access (NUMA) Architecture
    - Memory costs vary significantly: local vs remote
    - Which task to which processors?

Memory Hierarchy:
1) Main memory : 
    DRAM [Fast and volatile, but expensive relative to disk]
    CPU has direct access.
2) Disk : 
    Hard disks, solid-state disks [Slow, non-volatile, inexpensive]
    CPU doesn't have direct access

If CPU is 1 clock cycle, 1 GHz/1 nanosecond
Time to register, access and cache main memory: 100 nanoseconds

Caching: A very important principle applied in all layers of hardware, OS and software.
- Put frequently accessed data in small amount of faster memory
- Fast, most of the time (hit)
- Copy from slower memory to cache (miss)

Ballpark speed: 1ns -> 10ns -> 100ns -> 20 micro seconds -> 5 milliseconds

Interrupt:
- Signal to tell the processor "do something now!"
Hardware Interrupts: Devices (timer, disk, keyboard, ...) to CPU

Interrupt Handling:
- Save CPU states (registers)
- Execute the associated interupt service routine (ISR)
- Restore the CPU states
